#define THREADS 128

StructuredBuffer<float2> PositionsREAD;
RWStructuredBuffer<float2> PositionsWRITE;
StructuredBuffer<float2> VelocitiesREAD;
RWStructuredBuffer<float2> VelocitiesWRITE;
RWStructuredBuffer<float2> Lifetimes;
StructuredBuffer<float2> PredictedREAD;
RWStructuredBuffer<float2> PredictedWRITE;
AppendStructuredBuffer<uint> Dead;
ConsumeStructuredBuffer<uint> Pool;
AppendStructuredBuffer<uint> Alive;
StructuredBuffer<uint> Counter;
StructuredBuffer<float4> Uploads;

uint Width;
uint CounterOffset;
float Lifetime;
float DT;
float2 Gravity;
float Damping;

Texture2D<float3> _TerrainDistanceField;
SamplerState sampler_TerrainDistanceField;
float4 _TerrainDistanceFieldScale; // x = 1 / width, y = 1 / height, z = width, w = height
float _TerrainDistanceFieldMultiplier;

#pragma kernel Init
[numthreads(THREADS,1,1)]
void Init(uint id : SV_DispatchThreadID)
{
    if (id >= Width) return;

	PositionsWRITE[id] = float2(0, 0);
    VelocitiesWRITE[id] = float2(0, 0);
    Lifetimes[id] = float2(1, 0);
	Dead.Append(id);
}

#pragma kernel Emit
[numthreads(THREADS,1,1)]
void Emit (uint id : SV_DispatchThreadID)
{
	if (id < Width && id < Counter[CounterOffset]) {
		float4 upload = Uploads[id];
		uint idx = Pool.Consume();
        PositionsWRITE[idx] = upload.xy;
        VelocitiesWRITE[idx] = upload.zw;
        Lifetimes[idx] = float2(0, Lifetime);
	}
}

#pragma kernel PredictPositions
[numthreads(THREADS,1,1)]
void PredictPositions (uint id : SV_DispatchThreadID)
{
    if (id >= Width) return;

    float2 lifetime = Lifetimes[id];
    if (lifetime.x > lifetime.y) return;

    float2 velocity = VelocitiesREAD[id];
    velocity -= velocity * Damping * DT;
    velocity += Gravity * DT;
    PredictedWRITE[id] = PositionsREAD[id] + velocity * DT;
}

float2 normalized(float2 v)
{
    return v / max(length(v), 0.0001);
}

#pragma kernel SolveConstraints
[numthreads(THREADS,1,1)]
void SolveConstraints(uint id : SV_DispatchThreadID)
{
    if (id >= Width) return;

    const float2 lifetime = Lifetimes[id];
    if (lifetime.x > lifetime.y) return;

    float2 predicted = PredictedREAD[id];
    float2 uv = predicted * _TerrainDistanceFieldScale.xy + 0.5;
    float3 td = 2 * _TerrainDistanceField.SampleLevel(sampler_TerrainDistanceField, uv, 0) - 1;
    float distance = td.x * _TerrainDistanceFieldMultiplier;
    if (distance < 0.5) {
        const float2 n = normalized(td.yz);
        predicted += (0.5 - distance) * n;
    }
    PredictedWRITE[id] = predicted;
}

#pragma kernel Update
[numthreads(THREADS,1,1)]
void Update(uint id : SV_DispatchThreadID)
{
    if (id >= Width) return;

    float2 lifetime = Lifetimes[id];
    if (lifetime.x > lifetime.y) return;

    lifetime.x += DT;
    Lifetimes[id] = lifetime;
    if (lifetime.x > lifetime.y) {
        Dead.Append(id);
    } else {
        Alive.Append(id);
        float2 predictedPosition = PredictedREAD[id];
        VelocitiesWRITE[id] = (predictedPosition - PositionsWRITE[id]) / DT;
        PositionsWRITE[id] = predictedPosition; 
    }
}